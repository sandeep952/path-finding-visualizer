{"version":3,"sources":["components/Node/Node.js","components/PathFindingVisualizer.js","algorithms.js","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","id","isStart","isFinish","toggleStartFinish","isVisited","onClick","className","classNames","Component","rows","columns","PathFindingVisualizer","state","grid","startRow","startCol","finishRow","finishCol","distance","bind","initalizeGrid","reset","visualize","screenSize","window","screen","availWidth","row","col","updatedGrid","setState","cols","push","location","reload","start","dest","visitedNodes","visited","queue","prev","directions","visRow","prevRow","destinationFound","length","size","i","currNode","shift","currX","currY","k","direction","nextX","nextY","path","destNode","reverse","traceBackPath","bfs","animateBFS","setTimeout","animatePath","document","getElementById","classList","add","nodeSeq","Fragment","style","visibility","map","rowIndex","lineWidth","element","colIndex","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render"],"mappings":"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","file":"static/js/main.8d71bd06.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport \"./Node.css\";\nimport classNames from \"classnames\";\nclass Node extends Component {\n  render() {\n    let { id, isStart, isFinish, toggleStartFinish, isVisited } = this.props;\n    return (\n      <div\n        id={id}\n        onClick={toggleStartFinish}\n        className={classNames(\"box border border-primary\", {\n          \"bg-warning\": isStart,\n          \"bg-danger\": isFinish,\n        })}\n      ></div>\n    );\n  }\n}\n\nexport default Node;\n","import React, { Component } from \"react\";\nimport { bfs, traceBackPath } from \"../algorithms\";\nimport Node from \"./Node/Node\";\nlet rows = 18;\nlet columns = 50;\nclass PathFindingVisualizer extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      grid: [],\n\n      startRow: null,\n      startCol: null,\n      finishRow: null,\n      finishCol: null,\n      distance: null,\n    };\n    this.toggleStartFinish = this.toggleStartFinish.bind(this);\n    this.initalizeGrid = this.initalizeGrid.bind(this);\n    this.reset = this.reset.bind(this);\n    this.visualize = this.visualize.bind(this);\n  }\n\n  componentDidMount() {\n    let screenSize = window.screen.availWidth;\n\n    if (screenSize < 1300 && screenSize > 700) {\n      rows = 20;\n      columns = 25;\n    } else if (screenSize < 700 && screenSize > 500) {\n      rows = 15;\n      columns = 20;\n    } else if (screenSize < 500) {\n      rows = 15;\n      columns = 14;\n    }\n    this.initalizeGrid();\n  }\n\n  toggleStartFinish(row, col) {\n    let { grid } = this.state;\n    let { startRow, startCol, finishRow, finishCol } = this.state;\n    let updatedGrid = [...grid];\n\n    if (\n      startRow != null &&\n      startCol != null &&\n      finishRow != null &&\n      finishCol != null\n    )\n      return;\n    if (startRow != null && startCol != null) {\n      updatedGrid[row][col].isFinish = true;\n      finishRow = row;\n      finishCol = col;\n    } else {\n      updatedGrid[row][col].isStart = true;\n      startRow = row;\n      startCol = col;\n    }\n    this.setState({\n      grid: updatedGrid,\n      startRow,\n      startCol,\n      finishRow,\n      finishCol,\n    });\n  }\n\n  initalizeGrid() {\n    let grid = [];\n\n    for (let row = 0; row < rows; row++) {\n      let cols = [];\n      for (let col = 0; col < columns; col++) {\n        cols.push({\n          row,\n          col,\n          isStart: false,\n          isFinish: false,\n          isVisited: false,\n        });\n      }\n      grid.push(cols);\n    }\n    this.setState({\n      grid,\n      startRow: null,\n      startCol: null,\n      finishRow: null,\n      finishCol: null,\n    });\n  }\n\n  reset() {\n    // this.initalizeGrid();\n    window.location.reload();\n  }\n\n  visualize() {\n    let { grid, startRow, startCol, finishRow, finishCol } = this.state;\n    if (\n      startRow == null ||\n      startCol == null ||\n      !finishRow == null ||\n      finishCol == null\n    )\n      return;\n\n    let { visitedNodes, path, distance } = bfs(\n      grid[startRow][startCol],\n      grid[finishRow][finishCol],\n      grid,\n      rows,\n      columns\n    );\n\n    this.animateBFS(visitedNodes, grid);\n    setTimeout(() => {\n      this.animatePath(path);\n      this.setState({\n        distance,\n      });\n    }, visitedNodes.length * 25);\n  }\n\n  animatePath(path) {\n    for (let i = 0; i < path.length; i++) {\n      setTimeout(() => {\n        let currNode = path[i];\n        document\n          .getElementById(`node-${currNode.row}-${currNode.col}`)\n          .classList.add(\"path-node\");\n      }, i * 25);\n    }\n  }\n\n  animateBFS(nodeSeq, grid) {\n    for (let i = 0; i < nodeSeq.length; i++) {\n      setTimeout(() => {\n        let currNode = nodeSeq[i];\n        document\n          .getElementById(`node-${currNode.row}-${currNode.col}`)\n          .classList.add(\"visited-node\");\n      }, i * 25);\n    }\n  }\n\n  render() {\n    let { grid, distance } = this.state;\n    return (\n      <React.Fragment>\n        <h3>Path Finding Visualizer</h3>\n        <button className=\"btn btn-primary m-1\" onClick={this.reset}>\n          Reset\n        </button>\n        <button className=\"btn btn-warning\" onClick={this.visualize}>\n          Visualize\n        </button>\n        <p\n          className=\"distance lead\"\n          style={{ visibility: distance ? \"visible\" : \"hidden\" }}\n        >\n          Shortest Distance is {distance}\n        </p>\n        <div className=\"visualizer\">\n          {grid.map((row, rowIndex) => {\n            return (\n              <div key={`row${rowIndex}`} style={{ lineWidth: \"0px\" }}>\n                {row.map((element, colIndex) => (\n                  <Node\n                    id={`node-${rowIndex}-${colIndex}`}\n                    key={`node-${rowIndex}-${colIndex}`}\n                    {...grid[rowIndex][colIndex]}\n                    toggleStartFinish={() =>\n                      this.toggleStartFinish(rowIndex, colIndex)\n                    }\n                  />\n                ))}\n              </div>\n            );\n          })}\n        </div>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default PathFindingVisualizer;\n","export function bfs(start, dest, grid, rows, cols) {\n  // list to store the sequence of visited nodes\n  let visitedNodes = [];\n  let visited = [];\n  let queue = [];\n  let prev = [];\n  const directions = [\n    [0, 1], //up\n    [1, 0], //right\n    [0, -1], //down\n    [-1, 0], //left\n  ];\n\n  for (let row = 0; row < rows; row++) {\n    let visRow = [];\n    let prevRow = [];\n    for (let col = 0; col < cols; col++) {\n      visRow.push(false);\n      prevRow.push(null);\n    }\n    visited.push(visRow);\n    prev.push(prevRow);\n  }\n\n  queue.push(start);\n  visited[start.row][start.col] = true;\n\n  let distance = 0;\n  let destinationFound = false;\n  while (queue.length !== 0 && !destinationFound) {\n    let size = queue.length;\n    for (let i = 0; i < size; i++) {\n      let currNode = queue.shift();\n      let currX = currNode.row;\n      let currY = currNode.col;\n\n      visitedNodes.push(currNode);\n\n      for (let k = 0; k < directions.length; k++) {\n        let direction = directions[k];\n        let nextX = currX + direction[0];\n        let nextY = currY + direction[1];\n\n        if (\n          nextX >= 0 &&\n          nextX < rows &&\n          nextY >= 0 &&\n          nextY < cols &&\n          !visited[nextX][nextY]\n        ) {\n          if (nextX === dest.row && nextY === dest.col) {\n            prev[nextX][nextY] = currNode;\n            destinationFound = true;\n            break;\n          }\n\n          queue.push(grid[nextX][nextY]);\n          prev[nextX][nextY] = currNode;\n          visited[nextX][nextY] = true;\n        }\n      }\n    }\n    distance++;\n  }\n  let path = traceBackPath(grid, prev, dest);\n  return {\n    visitedNodes,\n    path,\n    distance,\n  };\n}\n\nexport function traceBackPath(grid, prev, destNode) {\n  let path = [];\n  let currNode = grid[destNode.row][destNode.col];\n  while (currNode != null) {\n    path.push(currNode);\n    currNode = prev[currNode.row][currNode.col];\n  }\n  path.reverse();\n  return path;\n}\n","import \"./App.css\";\nimport PathFindingVisualizer from \"./components/PathFindingVisualizer\";\n\nfunction App() {\n  return (\n    <div className=\"App mt-1\">\n      <PathFindingVisualizer />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n    <App />,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}