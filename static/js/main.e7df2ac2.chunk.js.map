{"version":3,"sources":["components/Node/Node.js","components/PathFindingVisualizer.js","algorithms.js","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","id","row","col","isStart","isFinish","wallMode","isWall","toggleWall","toggleStartFinish","nodeType","onClick","className","classNames","Component","columns","PathFindingVisualizer","state","grid","startRow","startCol","finishRow","finishCol","distance","bind","toggleWallMode","initalizeGrid","reset","visualize","screenSize","window","screen","availWidth","updatedGrid","setState","newGrid","cols","push","isVisited","location","reload","start","dest","rows","visitedNodes","visited","queue","prev","directions","visRow","prevRow","destinationFound","length","size","i","currNode","shift","currX","currY","k","direction","nextX","nextY","path","destNode","reverse","traceBackPath","bfs","animateBFS","setTimeout","animatePath","document","getElementById","classList","add","nodeSeq","console","log","Fragment","type","checked","onChange","htmlFor","style","visibility","map","rowIndex","lineWidth","element","colIndex","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render"],"mappings":"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","file":"static/js/main.e7df2ac2.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport \"./Node.css\";\nimport classNames from \"classnames\";\nclass Node extends Component {\n  render() {\n    let {\n      id,\n      row,\n      col,\n      isStart,\n      isFinish,\n      wallMode,\n      isWall,\n      toggleWall,\n      toggleStartFinish,\n      nodeType = \"\",\n    } = this.props;\n    return (\n      <div\n        id={id}\n        onClick={wallMode ? () => toggleWall(row, col) : toggleStartFinish}\n        className={classNames(\"box border border-primary\", {\n          \"start-node\": isStart,\n          \"destination-node\": isFinish,\n          \"wall-node\": isWall,\n          [nodeType]: true,\n        })}\n      ></div>\n    );\n  }\n}\n\nexport default Node;\n","import React, { Component } from \"react\";\nimport { bfs, traceBackPath } from \"../algorithms\";\nimport Node from \"./Node/Node\";\nlet rows = 18;\nlet columns = 50;\nclass PathFindingVisualizer extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      grid: [],\n      wallMode: false,\n      startRow: null,\n      startCol: null,\n      finishRow: null,\n      finishCol: null,\n      distance: null,\n    };\n    this.toggleWall = this.toggleWall.bind(this);\n    this.toggleWallMode = this.toggleWallMode.bind(this);\n    this.toggleStartFinish = this.toggleStartFinish.bind(this);\n    this.initalizeGrid = this.initalizeGrid.bind(this);\n    this.reset = this.reset.bind(this);\n    this.visualize = this.visualize.bind(this);\n  }\n\n  componentDidMount() {\n    let screenSize = window.screen.availWidth;\n\n    if (screenSize < 1300 && screenSize > 700) {\n      columns = 25;\n    } else if (screenSize < 700 && screenSize > 500) {\n      columns = 20;\n    } else if (screenSize < 500) {\n      columns = 14;\n    }\n    this.initalizeGrid();\n  }\n\n  toggleStartFinish(row, col) {\n    let { grid } = this.state;\n    let { startRow, startCol, finishRow, finishCol } = this.state;\n    let updatedGrid = [...grid];\n\n    if (\n      startRow != null &&\n      startCol != null &&\n      finishRow != null &&\n      finishCol != null\n    )\n      return;\n    if (startRow != null && startCol != null) {\n      updatedGrid[row][col].isFinish = true;\n      finishRow = row;\n      finishCol = col;\n    } else {\n      updatedGrid[row][col].isStart = true;\n      startRow = row;\n      startCol = col;\n    }\n    this.setState({\n      grid: updatedGrid,\n      startRow,\n      startCol,\n      finishRow,\n      finishCol,\n    });\n  }\n  toggleWall(row, col) {\n    let { grid } = this.state;\n    let newGrid = [...grid];\n    newGrid[row][col].isWall = true;\n    this.setState({\n      grid: newGrid,\n    });\n  }\n\n  initalizeGrid() {\n    let grid = [];\n\n    for (let row = 0; row < rows; row++) {\n      let cols = [];\n      for (let col = 0; col < columns; col++) {\n        cols.push({\n          row,\n          col,\n          isStart: false,\n          isFinish: false,\n          isVisited: false,\n        });\n      }\n      grid.push(cols);\n    }\n    this.setState({\n      grid,\n      wallMode: false,\n      startRow: null,\n      startCol: null,\n      finishRow: null,\n      finishCol: null,\n    });\n  }\n\n  reset() {\n    // this.initalizeGrid();\n    window.location.reload();\n  }\n\n  visualize() {\n    let { grid, startRow, startCol, finishRow, finishCol } = this.state;\n    if (\n      startRow == null ||\n      startCol == null ||\n      !finishRow == null ||\n      finishCol == null\n    )\n      return;\n\n    let { visitedNodes, path, distance } = bfs(\n      grid[startRow][startCol],\n      grid[finishRow][finishCol],\n      grid,\n      rows,\n      columns\n    );\n\n    this.animateBFS(visitedNodes, grid);\n    setTimeout(() => {\n      this.animatePath(path);\n      this.setState({\n        distance,\n      });\n    }, visitedNodes.length * 25);\n  }\n\n  animatePath(path) {\n    for (let i = 1; i < path.length - 1; i++) {\n      setTimeout(() => {\n        let currNode = path[i];\n        document\n          .getElementById(`node-${currNode.row}-${currNode.col}`)\n          .classList.add(\"path-node\");\n      }, i * 25);\n    }\n  }\n\n  animateBFS(nodeSeq, grid) {\n    for (let i = 1; i < nodeSeq.length - 1; i++) {\n      setTimeout(() => {\n        let currNode = nodeSeq[i];\n        document\n          .getElementById(`node-${currNode.row}-${currNode.col}`)\n          .classList.add(\"visited-node\");\n      }, i * 25);\n    }\n  }\n  toggleWallMode() {\n    this.setState({\n      wallMode: !this.state.wallMode,\n    });\n  }\n\n  render() {\n    console.log(\"rendering \");\n    let { grid, distance, wallMode } = this.state;\n    return (\n      <React.Fragment>\n        <h3>Path Finding Visualizer</h3>\n        <button className=\"btn btn-primary m-1\" onClick={this.reset}>\n          Reset\n        </button>\n        <button className=\"btn btn-warning\" onClick={this.visualize}>\n          Visualize\n        </button>\n        <div className=\"m-1\">\n          <div className=\"info-tab\">\n            <Node nodeType=\"start-node\" />\n            <span className=\"info-text\">Start</span>\n          </div>\n          <div className=\"info-tab\">\n            <Node nodeType=\"destination-node\" />\n            <span className=\"info-text\"> Destination</span>\n          </div>\n          <div className=\"info-tab\">\n            <Node nodeType=\"visited-node\" />\n            <span className=\"info-text\">Visited</span>\n          </div>\n          <div className=\"info-tab\">\n            <Node nodeType=\"path-node\" />\n            <span className=\"info-text\">Path</span>\n          </div>\n\n          <div className=\"custom-control custom-checkbox\">\n            <input\n              type=\"checkbox\"\n              className=\"custom-control-input\"\n              id=\"wallMode\"\n              checked={wallMode}\n              onChange={this.toggleWallMode}\n            />\n            <label className=\"custom-control-label\" htmlFor=\"wallMode\">\n              WallMode\n            </label>\n          </div>\n        </div>\n        <p\n          className=\"distance lead\"\n          style={{ visibility: distance ? \"visible\" : \"hidden\" }}\n        >\n          {distance !== -1\n            ? `Shortest Distance is ${distance}`\n            : \"NO PATH FOUND\"}\n        </p>\n        <div className=\"visualizer\">\n          {grid.map((row, rowIndex) => {\n            return (\n              <div key={`row${rowIndex}`} style={{ lineWidth: \"0px\" }}>\n                {row.map((element, colIndex) => (\n                  <Node\n                    id={`node-${rowIndex}-${colIndex}`}\n                    wallMode={wallMode}\n                    toggleWall={this.toggleWall}\n                    key={`node-${rowIndex}-${colIndex}`}\n                    {...grid[rowIndex][colIndex]}\n                    toggleStartFinish={() =>\n                      this.toggleStartFinish(rowIndex, colIndex)\n                    }\n                  />\n                ))}\n              </div>\n            );\n          })}\n        </div>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default PathFindingVisualizer;\n","export function bfs(start, dest, grid, rows, cols) {\n  // list to store the sequence of visited nodes\n  let visitedNodes = [];\n  let visited = [];\n  let queue = [];\n  let prev = [];\n  const directions = [\n    [0, 1], //up\n    [1, 0], //right\n    [0, -1], //down\n    [-1, 0], //left\n  ];\n\n  for (let row = 0; row < rows; row++) {\n    let visRow = [];\n    let prevRow = [];\n    for (let col = 0; col < cols; col++) {\n      visRow.push(false);\n      prevRow.push(null);\n    }\n    visited.push(visRow);\n    prev.push(prevRow);\n  }\n\n  queue.push(start);\n  visited[start.row][start.col] = true;\n\n  let distance = 0;\n  let destinationFound = false;\n  while (queue.length !== 0 && !destinationFound) {\n    let size = queue.length;\n    for (let i = 0; i < size; i++) {\n      let currNode = queue.shift();\n      let currX = currNode.row;\n      let currY = currNode.col;\n\n      visitedNodes.push(currNode);\n\n      for (let k = 0; k < directions.length; k++) {\n        let direction = directions[k];\n        let nextX = currX + direction[0];\n        let nextY = currY + direction[1];\n\n        if (\n          nextX >= 0 &&\n          nextX < rows &&\n          nextY >= 0 &&\n          nextY < cols &&\n          !visited[nextX][nextY]\n        ) {\n          if(grid[nextX][nextY].isWall)\n          continue\n          if (nextX === dest.row && nextY === dest.col) {\n            prev[nextX][nextY] = currNode;\n            destinationFound = true;\n            break;\n          }\n\n          queue.push(grid[nextX][nextY]);\n          prev[nextX][nextY] = currNode;\n          visited[nextX][nextY] = true;\n        }\n      }\n    }\n    distance++;\n  }\n  let path = traceBackPath(grid, prev, dest);\n  if(!path[0].isStart){\n    distance = -1;\n  }\n  return {\n    visitedNodes,\n    path,\n    distance,\n  };\n}\n\nexport function traceBackPath(grid, prev, destNode) {\n  let path = [];\n  let currNode = grid[destNode.row][destNode.col];\n  while (currNode != null) {\n    path.push(currNode);\n    currNode = prev[currNode.row][currNode.col];\n  }\n  path.reverse();\n  return path;\n}\n","import \"./App.css\";\nimport PathFindingVisualizer from \"./components/PathFindingVisualizer\";\n\nfunction App() {\n  return (\n    <div className=\"App mt-1\">\n      <PathFindingVisualizer />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n    <App />,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}