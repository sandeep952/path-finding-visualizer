[{"F:\\Sandeep\\WEB\\react\\path-finding-visualizer\\src\\index.js":"1","F:\\Sandeep\\WEB\\react\\path-finding-visualizer\\src\\reportWebVitals.js":"2","F:\\Sandeep\\WEB\\react\\path-finding-visualizer\\src\\App.js":"3","F:\\Sandeep\\WEB\\react\\path-finding-visualizer\\src\\components\\PathFindingVisualizer.js":"4","F:\\Sandeep\\WEB\\react\\path-finding-visualizer\\src\\components\\Node\\Node.js":"5","F:\\Sandeep\\WEB\\react\\path-finding-visualizer\\src\\algorithms.js":"6","F:\\Sandeep\\WEB\\react\\path-finding-visualizer\\src\\components\\InfoModal.js":"7","F:\\Sandeep\\WEB\\react\\path-finding-visualizer\\src\\components\\NavBar.js":"8"},{"size":457,"mtime":1607062274015,"results":"9","hashOfConfig":"10"},{"size":362,"mtime":499162500000,"results":"11","hashOfConfig":"10"},{"size":218,"mtime":1607253530314,"results":"12","hashOfConfig":"10"},{"size":7663,"mtime":1607254059595,"results":"13","hashOfConfig":"10"},{"size":911,"mtime":1607250373429,"results":"14","hashOfConfig":"10"},{"size":2045,"mtime":1607170183026,"results":"15","hashOfConfig":"10"},{"size":2578,"mtime":1607256477074,"results":"16","hashOfConfig":"10"},{"size":764,"mtime":1607253470542,"results":"17","hashOfConfig":"10"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},"1d8i2oi",{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"27","usedDeprecatedRules":"20"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"34","usedDeprecatedRules":"20"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"37","usedDeprecatedRules":"20"},"F:\\Sandeep\\WEB\\react\\path-finding-visualizer\\src\\index.js",[],["38","39"],"F:\\Sandeep\\WEB\\react\\path-finding-visualizer\\src\\reportWebVitals.js",[],"F:\\Sandeep\\WEB\\react\\path-finding-visualizer\\src\\App.js",[],"F:\\Sandeep\\WEB\\react\\path-finding-visualizer\\src\\components\\PathFindingVisualizer.js",["40"],"import React, { Component } from \"react\";\nimport { bfs, traceBackPath } from \"../algorithms\";\nimport InfoModal from \"./InfoModal\";\nimport NavBar from \"./NavBar\";\nimport Node from \"./Node/Node\";\nlet rows = 17;\nlet columns = 55;\nclass PathFindingVisualizer extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      grid: [],\n      wallMode: false,\n      startRow: null,\n      startCol: null,\n      finishRow: null,\n      finishCol: null,\n      distance: null,\n      showModal: true,\n      isMousePressed: false,\n    };\n    this.toggleModal = this.toggleModal.bind(this);\n    this.toggleWallMode = this.toggleWallMode.bind(this);\n    this.toggleStartFinish = this.toggleStartFinish.bind(this);\n    this.initalizeGrid = this.initalizeGrid.bind(this);\n    this.reset = this.reset.bind(this);\n    this.visualize = this.visualize.bind(this);\n  }\n\n  componentDidMount() {\n    let screenSize = window.screen.availWidth;\n\n    if (screenSize < 1400 && screenSize >= 1000) {\n      columns = 38;\n    } else if (screenSize < 1000 && screenSize >= 780) {\n      columns = 30;\n    } else if (screenSize < 780 && screenSize > 500) {\n      columns = 20;\n    } else if (screenSize < 500) {\n      columns = 14;\n    }\n    this.initalizeGrid();\n  }\n\n  toggleModal = () => {\n    this.setState({\n      showModal: !this.state.showModal,\n    });\n  };\n\n  toggleStartFinish(row, col) {\n    let { grid } = this.state;\n    let { startRow, startCol, finishRow, finishCol } = this.state;\n    let updatedGrid = [...grid];\n\n    if (\n      startRow != null &&\n      startCol != null &&\n      finishRow != null &&\n      finishCol != null\n    )\n      return;\n    if (startRow != null && startCol != null) {\n      updatedGrid[row][col].isFinish = true;\n      finishRow = row;\n      finishCol = col;\n    } else {\n      updatedGrid[row][col].isStart = true;\n      startRow = row;\n      startCol = col;\n    }\n    this.setState({\n      grid: updatedGrid,\n      startRow,\n      startCol,\n      finishRow,\n      finishCol,\n    });\n  }\n  getNewGridWithToggledWall = (row, col) => {\n    let { grid } = this.state;\n    let newGrid = [...grid];\n    newGrid[row][col].isWall = true;\n    return newGrid;\n  };\n\n  initalizeGrid() {\n    let grid = [];\n\n    for (let row = 0; row < rows; row++) {\n      let cols = [];\n      for (let col = 0; col < columns; col++) {\n        cols.push({\n          row,\n          col,\n          isStart: false,\n          isFinish: false,\n          isVisited: false,\n        });\n      }\n      grid.push(cols);\n    }\n    this.setState({\n      grid,\n      wallMode: false,\n      startRow: null,\n      startCol: null,\n      finishRow: null,\n      finishCol: null,\n      distance: null,\n      showModal: true,\n      isMousePressed: false,\n    });\n  }\n\n  reset() {\n    // this.initalizeGrid();\n    window.location.reload();\n  }\n\n  visualize() {\n    let { grid, startRow, startCol, finishRow, finishCol } = this.state;\n    if (\n      startRow == null ||\n      startCol == null ||\n      !finishRow == null ||\n      finishCol == null\n    )\n      return;\n\n    let { visitedNodes, path, distance } = bfs(\n      grid[startRow][startCol],\n      grid[finishRow][finishCol],\n      grid,\n      rows,\n      columns\n    );\n\n    this.animateBFS(visitedNodes, grid);\n    setTimeout(() => {\n      this.animatePath(path);\n      this.setState({\n        distance,\n      });\n    }, visitedNodes.length * 25);\n  }\n\n  handleMouseDown = (row, col) => {\n    let newGrid = this.getNewGridWithToggledWall(row, col);\n    this.setState({\n      grid: newGrid,\n      isMousePressed: true,\n    });\n  };\n\n  handleMouseUp = () => {\n    this.setState({\n      isMousePressed: false,\n    });\n  };\n\n  handleMouseEnter = (row, col) => {\n    let { isMousePressed } = this.state;\n    if (isMousePressed) {\n      let newGrid = this.getNewGridWithToggledWall(row, col);\n      this.setState({\n        grid: newGrid,\n      });\n    }\n  };\n\n  animatePath(path) {\n    for (let i = 1; i < path.length - 1; i++) {\n      setTimeout(() => {\n        let currNode = path[i];\n        document\n          .getElementById(`node-${currNode.row}-${currNode.col}`)\n          .classList.add(\"path-node\");\n      }, i * 25);\n    }\n  }\n\n  animateBFS(nodeSeq, grid) {\n    for (let i = 1; i < nodeSeq.length - 1; i++) {\n      setTimeout(() => {\n        let currNode = nodeSeq[i];\n        document\n          .getElementById(`node-${currNode.row}-${currNode.col}`)\n          .classList.add(\"visited-node\");\n      }, i * 25);\n    }\n  }\n  toggleWallMode() {\n    this.setState({\n      wallMode: !this.state.wallMode,\n    });\n  }\n\n  getStatusInfo = () => {\n    let status = \"default\";\n    let { wallMode, startRow, finishRow } = this.state;\n    if (wallMode) {\n      status = \"Click on the blocks to add walls\";\n    } else if (startRow != null && finishRow != null) {\n      status = \"Ready to visualise\";\n    } else if (startRow != null) {\n      status = \"Select destination\";\n    } else {\n      status = \"Select source\";\n    }\n    console.log(status);\n    return status;\n  };\n\n  render() {\n    let { grid, distance, wallMode, showModal } = this.state;\n    return (\n      <React.Fragment>\n        <NavBar visualize={this.visualize} reset={this.reset} />\n        <InfoModal showModal={showModal} toggleModal={this.toggleModal} />\n\n        <div className=\"m-1\"></div>\n\n        <div className=\"info-tab\">\n          <div className=\"box start-node\"></div>\n          <span className=\"info-text\">Start</span>\n        </div>\n\n        <div className=\"info-tab\">\n          <div className=\"box destination-node\"></div>\n          <span className=\"info-text\"> Destination</span>\n        </div>\n        <div className=\"info-tab\">\n          <div className=\"box visited-node\"></div>\n          <span className=\"info-text\">Visited</span>\n        </div>\n        <div className=\"info-tab\">\n          <div className=\"box path-node\"></div>\n          <span className=\"info-text\">Path</span>\n        </div>\n        <div className=\"info-tab\">\n          <div className=\"box wall-node\"></div>\n          <span className=\"info-text\">Path</span>\n        </div>\n\n        <div className=\"custom-control custom-checkbox mb-3\">\n          <input\n            type=\"checkbox\"\n            className=\"custom-control-input\"\n            id=\"wallMode\"\n            checked={wallMode}\n            onChange={this.toggleWallMode}\n          />\n          <label className=\"custom-control-label\" htmlFor=\"wallMode\">\n            Wall Mode\n          </label>\n        </div>\n        <span className=\"bg-dark text-white font-weight-light p-2 m-1\">\n          {!distance && this.getStatusInfo()}\n          {distance &&\n            (distance !== -1\n              ? `Shortest Distance is ${distance}`\n              : \"NO PATH FOUND\")}\n        </span>\n        <div className=\"visualizer mt-3\">\n          {grid.map((row, rowIndex) => {\n            return (\n              <div key={`row${rowIndex}`} style={{ lineWidth: \"0px\" }}>\n                {row.map((element, colIndex) => (\n                  <Node\n                    id={`node-${rowIndex}-${colIndex}`}\n                    wallMode={wallMode}\n                    handleMouseDown={this.handleMouseDown}\n                    handleMouseEnter={this.handleMouseEnter}\n                    handleMouseUp={this.handleMouseUp}\n                    key={`node-${rowIndex}-${colIndex}`}\n                    {...grid[rowIndex][colIndex]}\n                    toggleStartFinish={() =>\n                      this.toggleStartFinish(rowIndex, colIndex)\n                    }\n                  />\n                ))}\n              </div>\n            );\n          })}\n        </div>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default PathFindingVisualizer;\n","F:\\Sandeep\\WEB\\react\\path-finding-visualizer\\src\\components\\Node\\Node.js",[],"F:\\Sandeep\\WEB\\react\\path-finding-visualizer\\src\\algorithms.js",[],"F:\\Sandeep\\WEB\\react\\path-finding-visualizer\\src\\components\\InfoModal.js",["41"],"import { useState } from \"react\";\nimport { Button, Modal, ModalHeader, ModalBody, ModalFooter } from \"reactstrap\";\n\nconst tutorial = [\n  {\n    title: \"Welcome to Pathfinding Visualizer\",\n    content: [\n      `This short tutorial will walk you through all of the features of this application.`,\n      `If you want to dive right in, feel free to press the \"Skip Tutorial\" button below. Otherwise, press \"Next\"!`,\n    ],\n    image: \"\",\n  },\n  {\n    title: \"What is a pathfinding algorithm?\",\n    content: [\n      `A pathfinding algorithm finds the shortest path between two points. This application visualizes Breadth First Search (BFS) pathfinding algorithm!`,\n      `A BFS alogrithm moves level by level.\n      We can either move right,left ,up or down and movements from a node to another have a \"cost\" of 1.`,\n    ],\n    image: \"\",\n  },\n  {\n    title: \"Adding walls \",\n    content: [\n      `You can switch to wall mode by clicking on the checkbox and add walls in the grid.`,\n      `A wall will block the path and will not allow you to go through.`,\n    ],\n    image:\n      \"https://raw.githubusercontent.com/sandeep952/path-finding-visualizer/master/public/wallmode.jpg\",\n  },\n];\n\nconst InfoModal = (props) => {\n  const { showModal, toggleModal } = props;\n\n  const [currStep, setcurrStep] = useState(0);\n\n  const nextStep = () => setcurrStep(currStep + 1);\n\n  const previousStep = () => setcurrStep(currStep - 1);\n  const isLastSlide = currStep === tutorial.length - 1;\n  const isFirstSlide = currStep === 0;\n  const { title, content, image } = tutorial[currStep];\n  return (\n    <div>\n      <Modal isOpen={showModal} toggle={toggleModal}>\n        <ModalHeader toggle={toggleModal}>\n          <span style={{ fontSize: 28 }} className=\"text-center\">\n            {title}\n          </span>\n        </ModalHeader>\n        <ModalBody>\n          <div className=\"text-center lead\">\n            <p>{content[0]}</p>\n\n            <p style={{ fontSize: 18 }}>{content[1]}</p>\n\n            {image && <img src={image} width=\"100%\" height=\"100%\" />}\n          </div>\n        </ModalBody>\n        <ModalFooter>\n          <Button color=\"secondary\" onClick={toggleModal}>\n            {isLastSlide ? \"Finish\" : \"Skip tutorial\"}\n          </Button>\n          {!isFirstSlide && (\n            <Button color=\"primary\" onClick={previousStep}>\n              Previous\n            </Button>\n          )}\n          <Button color=\"primary\" onClick={nextStep} disabled={isLastSlide}>\n            Next\n          </Button>\n        </ModalFooter>\n      </Modal>\n    </div>\n  );\n};\n\nexport default InfoModal;\n","F:\\Sandeep\\WEB\\react\\path-finding-visualizer\\src\\components\\NavBar.js",["42","43","44","45"],"import React from \"react\";\nimport {\n  Collapse,\n  Navbar,\n  NavbarToggler,\n  NavbarBrand,\n  Nav,\n  NavItem,\n  NavLink,\n  NavbarText,\n} from \"reactstrap\";\n\nconst NavBar = (props) => {\n  return (\n    <div>\n      <Navbar color=\"dark\" light expand=\"md\">\n        <NavbarBrand href=\"/\">\n          <h3 className=\"text-white\">Path Finding Visualizer</h3>\n        </NavbarBrand>\n        <Nav className=\"ml-auto\" navbar>\n          <NavItem>\n            <button className=\"btn btn-primary m-1\" onClick={props.reset}>\n              Reset\n            </button>\n            <button className=\"btn btn-warning\" onClick={props.visualize}>\n              Visualize\n            </button>\n          </NavItem>\n        </Nav>\n      </Navbar>\n    </div>\n  );\n};\n\nexport default NavBar;\n",{"ruleId":"46","replacedBy":"47"},{"ruleId":"48","replacedBy":"49"},{"ruleId":"50","severity":1,"message":"51","line":2,"column":15,"nodeType":"52","messageId":"53","endLine":2,"endColumn":28},{"ruleId":"54","severity":1,"message":"55","line":58,"column":23,"nodeType":"56","endLine":58,"endColumn":69},{"ruleId":"50","severity":1,"message":"57","line":3,"column":3,"nodeType":"52","messageId":"53","endLine":3,"endColumn":11},{"ruleId":"50","severity":1,"message":"58","line":5,"column":3,"nodeType":"52","messageId":"53","endLine":5,"endColumn":16},{"ruleId":"50","severity":1,"message":"59","line":9,"column":3,"nodeType":"52","messageId":"53","endLine":9,"endColumn":10},{"ruleId":"50","severity":1,"message":"60","line":10,"column":3,"nodeType":"52","messageId":"53","endLine":10,"endColumn":13},"no-native-reassign",["61"],"no-negated-in-lhs",["62"],"no-unused-vars","'traceBackPath' is defined but never used.","Identifier","unusedVar","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","'Collapse' is defined but never used.","'NavbarToggler' is defined but never used.","'NavLink' is defined but never used.","'NavbarText' is defined but never used.","no-global-assign","no-unsafe-negation"]